import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import { useState, useEffect } from 'react';
import { Waypoint } from 'react-waypoint';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { PersonalHeader } from '../components/personal-theme-header';
import {
    MorePostsByPublicationDocument,
    MorePostsByPublicationQuery,
    MorePostsByPublicationQueryVariables,
    PageInfoFragment,
    PostFragment,
    PostsByPublicationDocument,
    PostsByPublicationQuery,
    PostsByPublicationQueryVariables,
    PublicationFragment,
} from '../generated/graphql';

const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;
const HOSTNAME = process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST; // Variable pour le hostname
const STATIC_PAGE_ID = process.env.NEXT_PUBLIC_STATIC_PAGE_ID || ""; // ID de la page statique

// Définir un type pour la réponse GraphQL des publications
interface PageResponse {
    post: {
        title: string;
        content: {
            html: string; // Ajout du sous-champ `html` pour le contenu
        };
    };
}

type Props = {
    publication: PublicationFragment;
    page: {
        title: string;
        content: string;
    };
    initialPageInfo: PageInfoFragment;
};

export default function Index({ publication, page, initialPageInfo }: Props) {
    const [pageInfo, setPageInfo] = useState<Props['initialPageInfo']>(initialPageInfo);
    const [loadedMore, setLoadedMore] = useState(false);

    // Ajouter les dépendances manquantes pour useEffect
    useEffect(() => {
        // Exemple d'effet secondaire (si nécessaire)
    }, [pageInfo]);

    const loadMore = async () => {
        const data = await request<MorePostsByPublicationQuery, MorePostsByPublicationQueryVariables>(
            GQL_ENDPOINT,
            MorePostsByPublicationDocument,
            {
                first: 20,
                host: HOSTNAME,
                after: pageInfo.endCursor,
            },
        );
        if (!data.publication) {
            return;
        }
        setPageInfo(data.publication.posts.pageInfo);
        setLoadedMore(true);
    };

    return (
        <AppProvider publication={publication}>
            <Layout>
                <Head>
                    <title>{page.title}</title>
                    <meta name="description" content="Page statique personnalisée" />
                    <meta property="twitter:card" content="summary_large_image" />
                    <meta property="twitter:title" content={page.title} />
                    <meta property="twitter:description" content="Page statique personnalisée" />
                    <meta
                        property="og:image"
                        content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
                    />
                    <meta
                        property="twitter:image"
                        content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
                    />
                    <script
                        type="application/ld+json"
                        dangerouslySetInnerHTML={{
                            __html: JSON.stringify(addPublicationJsonLd(publication)),
                        }}
                    />
                </Head>
                <Container className="mx-auto flex max-w-3xl flex-col items-stretch gap-10 px-5 py-10">
                    <PersonalHeader />
                    <div>
                        <h1>{page.title}</h1>
                        <div dangerouslySetInnerHTML={{ __html: page.content }} />
                    </div>
                    {!loadedMore && pageInfo.hasNextPage && pageInfo.endCursor && (
                        <button onClick={loadMore}>Load more</button>
                    )}
                    {loadedMore && pageInfo.hasNextPage && pageInfo.endCursor && (
                        <Waypoint onEnter={loadMore} bottomOffset={'10%'} />
                    )}
                    <Footer />
                </Container>
            </Layout>
        </AppProvider>
    );
}

export const getStaticProps: GetStaticProps<Props> = async () => {
    // Requête pour récupérer les informations de la publication
    const publicationData = await request<PostsByPublicationQuery, PostsByPublicationQueryVariables>(
        GQL_ENDPOINT,
        PostsByPublicationDocument,
        {
            first: 20,
            host: HOSTNAME,
        },
    );

    // Vérifier si l'ID de la page statique est défini
    if (!STATIC_PAGE_ID) {
        console.error("L'ID de la page statique (NEXT_PUBLIC_STATIC_PAGE_ID) n'est pas défini.");
        return {
            notFound: true,
        };
    }

    // Requête pour récupérer la page statique avec un ID dynamique
    const pageQuery = `
    query {
      post(id: "${STATIC_PAGE_ID}") {
        title
        content {
          html
        }
      }
    }
  `;
    try {
        const pageData = await request<PageResponse>(GQL_ENDPOINT, pageQuery); // Cast the response to PageResponse

        if (!pageData.post) {
            console.error("La page statique avec l'ID spécifié n'a pas été trouvée.");
            return {
                notFound: true,
            };
        }

        const publication = publicationData.publication;
        if (!publication) {
            return {
                notFound: true,
            };
        }

        return {
            props: {
                publication,
                page: {
                    title: pageData.post.title,
                    content: pageData.post.content.html, // Utiliser le sous-champ `html`
                },
                initialPageInfo: publication.posts.pageInfo,
            },
            revalidate: 1,
        };
    } catch (error) {
        console.error("Erreur lors de la récupération de la page statique :", error);
        return {
            notFound: true,
        };
    }
};
