import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import Image from 'next/image'; // Importation de next/image pour optimiser les images
import { useState, useEffect } from 'react';
import { Waypoint } from 'react-waypoint';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { PersonalHeader } from '../components/personal-theme-header';
import {
    MorePostsByPublicationDocument,
    MorePostsByPublicationQuery,
    MorePostsByPublicationQueryVariables,
    PageInfoFragment,
    PublicationFragment,
} from '../generated/graphql';

const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;
const HOSTNAME = process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST; // Variable pour le hostname
const STATIC_PAGE_SLUG = process.env.NEXT_PUBLIC_STATIC_PAGE_SLUG || ""; // Slug de la page statique

// Définir un type pour la réponse GraphQL des publications
interface StaticPageResponse {
    publication: {
        staticPage: {
            id: string;
            title: string;
            content: {
                html: string; // Ajout du sous-champ `html` pour le contenu
            };
        };
    };
}

type Props = {
    publication: PublicationFragment;
    page: {
        title: string;
        content: string;
    };
    initialPageInfo: PageInfoFragment;
};

export default function Index({ publication, page, initialPageInfo }: Props) {
    const [pageInfo, setPageInfo] = useState<Props['initialPageInfo']>(initialPageInfo);
    const [loadedMore, setLoadedMore] = useState(false);

    // Correction des hooks React : ajout des dépendances manquantes
    useEffect(() => {
        // Logique ici (si nécessaire)
    }, [pageInfo]); // Ajouter les dépendances nécessaires

    const loadMore = async () => {
        const data = await request<MorePostsByPublicationQuery, MorePostsByPublicationQueryVariables>(
            GQL_ENDPOINT,
            MorePostsByPublicationDocument,
            {
                first: 20,
                host: HOSTNAME,
                after: pageInfo.endCursor,
            },
        );
        if (!data.publication) {
            return;
        }
        setPageInfo(data.publication.posts.pageInfo);
        setLoadedMore(true);
    };

    return (
        <AppProvider publication={publication}>
            <Layout>
                <Head>
                    <title>{page.title}</title>
                    <meta name="description" content="Page statique personnalisée" />
                    <meta property="twitter:card" content="summary_large_image" />
                    <meta property="twitter:title" content={page.title} />
                    <meta property="twitter:description" content="Page statique personnalisée" />
                    <meta
                        property="og:image"
                        content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
                    />
                    <meta
                        property="twitter:image"
                        content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
                    />
                    <script
                        type="application/ld+json"
                        dangerouslySetInnerHTML={{
                            __html: JSON.stringify(addPublicationJsonLd(publication)),
                        }}
                    />
                </Head>
                <Container className="mx-auto flex max-w-3xl flex-col items-stretch gap-10 px-5 py-10">
                    <PersonalHeader />
                    <div>
                        <h1 className="text-4xl font-bold mb-6">{page.title}</h1>
                        <div
                            className="prose lg:prose-xl"
                            dangerouslySetInnerHTML={{ __html: page.content }}
                        />
                    </div>
                    {!loadedMore && pageInfo.hasNextPage && pageInfo.endCursor && (
                        <button onClick={loadMore}>Load more</button>
                    )}
                    {loadedMore && pageInfo.hasNextPage && pageInfo.endCursor && (
                        <Waypoint onEnter={loadMore} bottomOffset={'10%'} />
                    )}
                    <Footer />
                </Container>
            </Layout>
        </AppProvider>
    );
}

export const getStaticProps: GetStaticProps<Props> = async () => {
    // Requête pour récupérer les informations de la publication
    const publicationData = await request(
        GQL_ENDPOINT,
        `
      query {
        publication(host: "${HOSTNAME}") {
          posts(first: 20) {
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }
      }
    `,
    );

    // Vérifier si le slug de la page statique est défini
    if (!STATIC_PAGE_SLUG) {
        console.error("Le slug de la page statique (NEXT_PUBLIC_STATIC_PAGE_SLUG) n'est pas défini.");
        return {
            notFound: true,
        };
    }

    // Requête pour récupérer la page statique avec un slug dynamique
    const staticPageQuery = `
    query {
      publication(host: "${HOSTNAME}") {
        staticPage(slug: "${STATIC_PAGE_SLUG}") {
          id
          title
          content {
            html
          }
        }
      }
    }
  `;
    try {
        const staticPageData = await request<StaticPageResponse>(GQL_ENDPOINT, staticPageQuery); // Cast the response to StaticPageResponse

        if (!staticPageData.publication?.staticPage) {
            console.error("La page statique avec le slug spécifié n'a pas été trouvée.");
            return {
                notFound: true,
            };
        }

        const publication = publicationData.publication;
        if (!publication) {
            return {
                notFound: true,
            };
        }

        return {
            props: {
                publication,
                page: {
                    title: staticPageData.publication.staticPage.title,
                    content: staticPageData.publication.staticPage.content.html, // Utiliser le sous-champ `html`
                },
                initialPageInfo: publication.posts.pageInfo,
            },
            revalidate: 1,
        };
    } catch (error) {
        console.error("Erreur lors de la récupération de la page statique :", error);
        return {
            notFound: true,
        };
    }
};
